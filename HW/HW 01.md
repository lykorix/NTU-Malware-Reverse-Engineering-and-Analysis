# HW Report

## 1. Name: 劉浩恩 &nbsp; Student ID: M11015060


## 2.
main呼叫的subroutine 其執行InternetGetConnectedState()，檢查網路是否連接。
若連接則print *Success: Internet Connection*，並回傳1；反之則 print *Error 1.1: No Internet*，並回傳0。

0x40105F 的 subroutine 為 printf。

此程式用以檢測網路是否連接。

## 3.
main第一個呼叫的subroutine 其執行InternetGetConnectedState()，檢查網路是否連接。
若連接則print *Success: Internet Connection*，並回傳1；反之則 print *Error 1.1: No Internet*，並回傳0。

0x40117F 的 subroutine 為 printf。
  

main第二個呼叫的subroutine 首先用InternetOpenA 設定 Internet Explorer 7.5 並以InternetOpenUrlA開啟 `http://www.practicalmalwareanalysis.com/cc.htm`  的頁面，再以InternetReadFile 讀取網頁中檔案，若無法開啟Url 則 printf *Error 2.1: Fail to OpenUrl*，並終止連接；若無法讀取檔案則printf *Error 2.2: Fail to ReadFile*，並終止連接；若parse HTML後比較buffer中四個byte為`<!--`，是則回傳第五個byte之值；否則print Error 2.3: *Fail to get command*，並回傳0。

此subroutine 使用一個buffer (array)存取InternetReadFile 從網頁讀取的值，進行對html 的parse。

此程式有兩個network-based 的指標： 
User-Agent：Internet Explorer 7.5/pma，及 szUrl：`http://www.practicalmalwareanalysis.com/cc.htm`。

程式首先確認網路是否連接，若否則終止。
確認Url是否能開啟，若否則終止連接。
確認網頁中檔案是否能讀取，若否則終止連接。
parse HTML 並比較其值，若不符則回傳0。
若完成parse，則print *Success: Parsed command is ..* 並 sleep 1 分鐘。

## 4.
位在 0x401000 的function 其執行InternetGetConnectedState()，檢查網路是否連接。若連接則print *Success: Internet Connection*，並回傳1；反之則 print *Error 1.1: No Internet*，並回傳0。
位在 0x401040 的function 首先用InternetOpenA 設定 Internet Explorer 7.5 並以InternetOpenUrlA開啟 `http://www.practicalmalwareanalysis.com/cc.htm` 的頁面，再以InternetReadFile 讀取網頁中檔案，若無法開啟Url 則 printf *Error 2.1: Fail to OpenUrl*，並終止連接；若無法讀取檔案則 printf *Error 2.2: Fail to ReadFile*，並終止連接；若parse HTML後比較buffer中四個byte為`<!--`，是則回傳第五個byte之值；否則print Error 2.3: *Fail to get command*，並回傳0。
位在 0x401271 的 function 為 printf。
位在 0x401130 的 function 為新的 function。

此 function 用到兩個參數，其一為位在 0x401000 function 的回傳值(即 parse HTML 後所得值)，其二為argv[0]，為指向 function 的指標。

此 function 包含了 switch 條件判斷。

此 function 可以create a directory、, copy a file、delete a file,、set a registry value、print error messages、Sleep for 100 seconds。

registry key 指向 Software\Microsoft\Windows\CurrentVersion\Run，Data 指向 C:\Temp\cc.exe，PathName 指向 C:\Temp。

程式首先確認網路是否連接，若否則終止。
確認Url是否能開啟，若否則終止連接。
確認網頁中檔案是否能讀取，若否則終止連接。
parse HTML 並比較其值，若不符則回傳0。
若完成parse，則回傳值並在 switch 判斷中用於決定create a directory、 copy a file、delete a file,、set a registry value、print error messages、sleep for 100 seconds  在 local system 其中之一的操作。

## 5.
Lab6-4 增加了一個迴圈，使位在0x401040 的 function (parse HTML) 及 位在0x401150 的function (switch 判斷) 會重複執行1440次。

增加了一個重複執行1440次的迴圈。

parse HTML function 增加了一個計算迴圈執行次數的參數，當此 function 執行時會print *Internet Explorer 7.50/pma'執行次數'*。

若進行switch判斷時皆不進行sleep，則最少執行60*1440=86400；若進行switch判斷時皆進行 sleep 100秒，則最多執行(60+100)*1440=230400秒 。

此程式有一個新的 network-based 指標為 User-Agent: Internet Explorer 7.50/pma%d。

程式首先確認網路是否連接，若否則終止。
確認Url是否能開啟，若否則終止連接。
確認網頁中檔案是否能讀取，若否則終止連接。
parse HTML 並比較其值，若不符則回傳0。
若完成parse，則回傳值並在 switch 判斷中用於決定create a directory、 copy a file、delete a file,、set a registry value、print error messages、sleep for 100 seconds  在 local system 其中之一的操作。
完成後反覆執行1440次。

## 6.
當密碼不正確時，程式輸出 Incorrect Password。
在IDA pro 中找到此判斷式：
```
  if ( String[1] != 97 || strncmp(&String[2], Str2, 2u) || 
  strcmp(&String[4], aR3versing) || String[0] != 69 )
    return MessageBoxA(hDlg, aIncorrectPassw, Caption, 0x10u);
```
得知String[0] 為 69 (ascii 為 E)，String[1] 為 97 (ascii 為 a)。
String[2]放在Str2中，值為5y的字串。
String[4]放在aR3versing，值為R3versing的字串。

故 correct Password 為 **Ea5yR3versing**。

![](https://i.imgur.com/I82fi2p.png)

## 7.
使用IDA pro 觀察main()，發現解為 [esp+esi+13Ch+var_130] XOR [esp+ebp+13Ch+var_12C]。
var_130為陣列 [0x10, 0x20, 0x30]，var_12為 Input Name: 後 scanf 所得之值。
其使用迴圈輪流使用var_130[0]、var_130[1]、var_130[2] 對 var_12C 進行 XOR 運算。

故可用 Input Serial : *5B134977135E7D13* XOR var_130[0]、var_130[1]、var_130[2] 反推得出 Input Name。

程式碼如下：

```
#include <stdio.h>
#include <string.h>

main()
{
    signed int v3 = 0;              // ebp
    int i = 0;                      // esi
    int v7[3] = {0x10, 0x20, 0x30}; // [esp+Dh] [ebp-12Fh] BYREF
    int v8[8] = {0x5B,
                 0x13,
                 0x49,
                 0x77,
                 0x13,
                 0x5E,
                 0x7D,
                 0x13};
    char Buffer[197];
    memset(Buffer, 0, sizeof(Buffer));
    for (i = 0; v3 < 8; ++i)
    {

        if (i >= 3)
            i = 0;
        sprintf(Buffer, "%s%02X", Buffer, v8[v3] ^ v7[i]);
        v3++;
    }
    puts(Buffer);
    return 0;
}
```

得出答案4B337967336E6D33，hex 轉 ascii 為 K3yg3nm3。
A：**K3yg3nm3**

![](https://i.imgur.com/QY8GCJH.png)
